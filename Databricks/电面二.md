# 电面二总结

[题库](https://leetcode.com/company/databricks/)

## [742. Closest Leaf in a Binary Tree](https://leetcode.com/problems/closest-leaf-in-a-binary-tree/)
看成一个图，从 target node 去找叶子节点

DFS 构图，找到 start node， O(n)
BFS 找叶子节点，O(n)

Time: O(n)
Space: O(n) 存放边和节点

```python
from collections import deque

class Solution:
    def findClosestLeaf(self, root, k):
        if root is None:
            return -1
        
        parents = {}
        target = self.find_target(root, k, parents)
        
        queue = deque([target])
        visited = {target}
        while queue:
            node = queue.popleft()
            
            if not node.left and not node.right:
                return node.val
            if node.left and node.left not in visited:
                queue.append(node.left)
                visited.add(node.left)
            if node.right and node.right not in visited:
                queue.append(node.right)
                visited.add(node.right)
            if node in parents and parents[node] not in visited:
                queue.append(parents[node])
                visited.add(parents[node])
        
        return -1

    def find_target(self, root, k, parents):
        if root is None:
            return None
        
        result = root
        node = None
        
        if root.left:
            parents[root.left] = root
            node = self.find_target(root.left, k, parents)
            if node.val == k:
                result = node
        if root.right:
            parents[root.right] = root
            node = self.find_target(root.right, k, parents)
            if node.val == k:
                result = node
        return result
```

## [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)
### 方法一
不断交换 nums[i] 和 nums[nums[i] - 1]，注意 nums[i] != nums[nums[i] - 1] 和 0 <= nums[i] < n
Time: O(n)
Space: O(1)

```python
class Solution:
    def firstMissingPositive(self, nums):
        n = len(nums)
        
        for i in range(n):
            while 0 <= nums[i] < n and nums[i] != i + 1 and nums[i] != nums[nums[i] - 1]:
                temp = nums[nums[i] - 1]
                nums[nums[i] - 1] = nums[i]
                nums[i] = temp
                
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        return n + 1
```

### 方法二
使用 HashMap { n: n } 如果 num in hash_map，就删除 hash_map[num]，返回 min(hash_map)，就是第一个 Missing 正整数
注意这里是 1 -> n + 1

Time: O(n)
Space: O(n)

```python
class Solution:
    def firstMissingPositive(self, nums):
        store = { n : n for n in range(1, len(nums) + 2) }
        
        for num in nums:
            if num in store:
                del store[num]
    
        return min(store)
```

## [218. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)
### 方法一
分成左右两边 get skyline，再合并。每次如果 y 值变化了，就要更新一下 skyline

Time: O(nlogn) -> T(n) = 2 * T(n/2) + 2N -> O(nlogn)
Space: O(n) -> 保存结果

```python
class Solution:
    """
    @param buildings: A list of lists of integers
    @return: Find the outline of those buildings
    """
    def getSkyline(self, buildings):
        n = len(buildings)

        # Base case
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            # 左上和右下
            return [[x_start, y], [x_end, 0]]

        left_skyline = self.getSkyline(buildings[:n // 2])
        right_skyline = self.getSkyline(buildings[n // 2:])

        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left_skyline, right_skyline):
        left_len, right_len = len(left_skyline), len(right_skyline)
        left = right = 0
        current_y = left_y = right_y = 0
        skyline = []

        # 合并共有的部分
        while left < left_len and right < right_len:
            left_point, right_point = left_skyline[left], right_skyline[right]
            # 选择第一个点
            if left_point[0] < right_point[0]:
                x, left_y = left_point
                left += 1
            else:
                x, right_y = right_point
                right += 1

            # 合并楼层的高
            max_y = max(left_y, right_y)
            # 如果 y 值要变，要更新 skyline 了
            if max_y != current_y:
                self.update_skyline(x, max_y, skyline)
                current_y = max_y

        # 将剩下的部分加入到 skyline
        self.append_skyline(left_skyline, left, left_len, current_y, skyline)
        self.append_skyline(right_skyline, right, right_len, current_y, skyline)

        return skyline

    def update_skyline(self, x, y, skyline):
        # 没有这个点的时候就加入
        if not skyline or skyline[-1][0] != x:
            skyline.append([x, y])
        # 否则更新最后一个点的 y 值
        else:
            skyline[-1][1] = y

    def append_skyline(self, rest_skyline, start, length, current_y, skyline):
        for i in range(start, length):
            x, y = rest_skyline[i]
            # 如果 y 值要变，要更新 skyline 了
            if current_y != y:
                self.update_skyline(x, y, skyline)
                current_y = y
```

## [239. Sliding Window Maximum]()

### 方法一
Brute Force
Time: O((n - k + 1) * k) -> O(n^2)
Space: O(1)

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        window = deque([])
        
        n = len(nums)
        k = min(n, k)
        
        for i in range(k - 1):
            window.append(nums[i])
        
        results = []
        for i in range(k - 1, n):
            window.append(nums[i])
            
            results.append(max(window))
            
            window.popleft()
        
        return results
```

### 方法二
BST
Time: O((n - k + 1) * logk)
Space: O(k)

```python
import heapq

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        n = len(nums)
        k = min(k, n)
        
        window = []
        
        for i in range(k - 1):
            heapq.heappush(window, -nums[i])
        
        results = []
        for i in range(k - 1, n):
            # 加入右边一个元素
            heapq.heappush(window, -nums[i])
            # 获取当前最大值 
            results.append(-window[0])
            # 从 heap 中移除左边的元素
            window.remove(-nums[i - k + 1])
            heapq.heapify(window)
        
        return results
```
### 方法三
单调双端队列

Time: O(n)
Space: O(k)

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        n = len(nums)
        k = min(k, n)
        
        
        queue = deque([])
        for i in range(k - 1):
            self.push(nums, queue, i)
            
        results = []
        for i in range(k - 1, n):
            self.push(nums, queue, i)
            results.append(nums[queue[0]])
            
            if i - k + 1 == queue[0]:
                queue.popleft()
        
        return results
    
    def push(self, nums, queue, i):
        while queue and nums[queue[-1]] < nums[i]:
            queue.pop()
        queue.append(i)
```

## [91. Decode Ways](https://leetcode.com/problems/decode-ways/)

### 方法一
dp 解法，dp[i] = dp[i - 1] + dp[i - 2] | dp[i - 1] } dp[i - 2]
如果遇到 0，就返回 0，因为此处不能解码

Time: O(n)
Space: O(n)

```python
class Solution:
    def numDecodings(self, s):
        if not s or s[0] == '0':
            return 0
        
        n = len(s)
        dp = [0 for _ in range(n + 1)]
        dp[0], dp[1] = 1, 1
        
        for i in range(2, n + 1):
            if 10 <= int(s[i - 2:i]) <= 26 and s[i - 1] != '0':
                dp[i] = dp[i - 2] + dp[i - 1]
            elif int(s[i - 2:i]) == 10 or int(s[i - 2:i]) == 20:
                dp[i] = dp[i - 2]
            elif s[i - 1] != '0':
                dp[i] = dp[i - 1]
            else:
                return 0
        
        return dp[n]
```

### 方法二
dfs + memo

Time: O(n) ，如果不用 memo 就是 O(2^n)，因为用了 memo ，所以每次只需要访问所以 index，就是 O(n)
Space: O(n)

```python
class Solution:
    def numDecodings(self, s):
        if not s or s[0] == '0':
            return 0
            
        return self.dfs(s, 0, {})
    
    def dfs(self, s, start, memo):
        if start in memo:
            return memo[start]
            
        if start == len(s):
            return 1
            
        if s[start] == '0':
            return 0
        
        result = self.dfs(s, start + 1, memo)
        
        if start + 2 <= len(s) and int(s[start: start + 2]) <= 26:
            result += self.dfs(s, start + 2, memo)
        
        memo[start] = result
        return result
```

## [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)
### 方法一
Array + Hash Table
删除的时候将最后一个放到 index，再 pop() 即可

Time: O(1)
Space: O(n)

```python
import random

class RandomizedSet:

    def __init__(self):
        self.nums = []
        self.positions = {}
        self.length = 0
        
    def insert(self, val: int) -> bool:
        if val in self.positions:
            return False
        
        self.nums.append(val)
        self.positions[val] = self.length
        self.length += 1
        
        return True
        
    def remove(self, val: int) -> bool:
        if val not in self.positions:
            return False
        
        last, index = self.nums[-1], self.positions[val]
        
        self.nums[index] = last
        self.positions[last] = index
        
        self.nums.pop()
        
        del self.positions[val]
        self.length -= 1
        
        return True

    def getRandom(self) -> int:
        return self.nums[random.randint(0, self.length - 1)]
```

## [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)
### 方法一
将删除的变成 None

Time: O(1)
Space: O(n)

```python
from collections import defaultdict
import random

class RandomizedCollection:

    def __init__(self):
        self.nums = []
        self.positions = defaultdict(set)
        self.length = 0
        

    def insert(self, val: int) -> bool:
        self.nums.append(val)
        self.positions[val].add(self.length)
        self.length += 1
        
        return len(self.positions[val]) == 1
        

    def remove(self, val: int) -> bool:
        if not self.positions[val]:
            return False
        
        index = self.positions[val].pop()
        
        self.nums[index] = None
        self.length -= 1
        return True
        

    def getRandom(self) -> int:
        x = None
        while x is None:
            x = random.choice(self.nums)
            
        return x
```

## [426. Convert Binary Search Tree to Sorted Doubly Linked List](https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)
### 方法一
分治法

Time: O(n)，因为每个节点只遍历一次
Space: O(n)，最差情况递归深度是 n，所以是 O(n)

```python
class Solution:
    def __init__(self):
        self.first = None
        self.prev = None
    """
    @param root: root of a tree
    @return: head node of a doubly linked list
    """
    def treeToDoublyList(self, root):
        if root is None:
            return None
        
        head, tail = self.dfs(root)
        
        tail.right = head
        head.left = tail
        
        return head
        
    def dfs(self, root):
        if root is None:
            return None, None
            
        left_head, left_tail = self.dfs(root.left)
        right_head, right_tail = self.dfs(root.right)
        
        if left_tail:
            left_tail.right = root
            root.left = left_tail
        if right_head:
            root.right = right_head
            right_head.left = root
        
        head = left_head or root or right_head
        tail = right_tail or root or left_tail
        
        return head, tail
```

## [378. Convert Binary Tree to Doubly Linked List](https://www.lintcode.com/problem/convert-binary-tree-to-doubly-linked-list/description)
### 方法一
分治法即可，左边生成 doubly linked list，右边生成 doubly linked list，全在一起就可以了

Time: O(n)，遍历 n 个 node
Space: O(n)，递归 n 次加上 n 个节点

```python
class Solution:
    def __init__(self):
        self.first = None
        self.prev = None
    """
    @param root: The root of tree
    @return: the head of doubly list node
    """
    def bstToDoublyList(self, root):
        if root is None:
            return root
        
        head, _ = self.dfs(root)

        return head
        
    def dfs(self, root):
        if root is None:
            return None, None
        
        left_head, left_tail = self.dfs(root.left)
        right_head, right_tail = self.dfs(root.right)
        
        curt = DoublyListNode(root.val)
        
        if left_tail:
            left_tail.next = curt
            curt.prev = left_tail
        if right_head:
            curt.next = right_head
            right_head.prev = curt
            
        head = left_head or curt or right_head
        tail = right_tail or curt or left_tail
        
        return head, tail
```

## [350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)
### 方法一
两个数组先排序，再合并

Time: O(nlogn + mlongm)，要排序所以 nlogn + mlogm
Space: O(1)

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        
        i, j = 0, 0
        m, n = len(nums1), len(nums2)
        
        results = []
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                results.append(nums1[i])
                i += 1
                j += 1
        return results
```

### 方法二
Count 其中一个数组元素个数，再去看另一个数组里这些元素是否存在于 Counter

Time: O(n + m)
Space: O(1)

```python
class Solution:
    def intersection(self, nums1, nums2):
        store = collections.Counter(nums1)
        
        results = []
        for num in nums2:
            if num in store and store[num] > 0:
                results.append(num)
                store[num] -= 1
        return results
```

## [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)
### 方法一
两个 dict 存 value 和 time，每次获取就二分查找

Time: O(logn)
Space: O(n)

```python
from collections import defaultdict

class TimeMap:

    def __init__(self):
        self.values = defaultdict(list)
        self.times = defaultdict(list)
        

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.values[key].append(value)
        self.times[key].append(timestamp)
        

    def get(self, key: str, timestamp: int) -> str:
        index = self.binary_search(self.times[key], timestamp)
        
        return '' if index == -1 else self.values[key][index]
    
    def binary_search(self, nums, target):
        left, right = 0, len(nums) - 1
        while left + 1 < right:
            mid = (left + right) // 2
            
            if nums[mid] <= target:
                left = mid
            else:
                right = mid
        
        if nums[right] <= target:
            return right
        if nums[left] <= target:
            return left
        return -1
```

## [314. Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/)

### 方法一
BFS 去找 index

Time: O(n)，找所有节点所以是 n
Space: O(n)，queue 要 n

```python
from collections import deque
from collections import defaultdict
class Solution:
    def verticalOrder(self, root):
        if root is None:
            return []
        
        queue = deque([(root, 0)])
        levels = defaultdict(list)
        
        while queue:
            node, index = queue.popleft()
            
            if node.left:
                queue.append((node.left, index - 1))
            if node.right:
                queue.append((node.right, index + 1))
            
            levels[index].append(node.val)
        
        order = []
        for index in sorted(levels):
            order.append(levels[index])
        return order
```

### 方法二
DFS 找 index，要注意的是，这里不用对 root.val 进行排序

```python
from collections import defaultdict
class Solution:
    def verticalOrder(self, root):
        if root is None:
            return []
        
        mapping = []
        
        self.dfs(root, mapping, 0, 0)
        
        mapping = sorted(mapping, key=lambda x: (x[0], x[1]))
        
        store = defaultdict(list)
        for x, y, value in mapping:
            store[x].append(value)
        
        return store.values()
    
    def dfs(self, root, mapping, x, y):
        if root is None:
            return
        
        mapping.append((x, y, root.val))
        self.dfs(root.left, mapping, x - 1, y + 1)
        self.dfs(root.right, mapping, x + 1, y + 1)

```

## [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)

### 方法一
DFS 找 index，注意这里要对 root.val 进行排序

Time: O(nlogn)
Space: O(n)

```python
from collections import defaultdict
class Solution:
    def verticalTraversal(self, root):
        if root is None:
            return []
        
        mapping = []
        
        self.dfs(root, mapping, 0, 0)
        
        mapping = sorted(mapping, key=lambda x: (x[0], x[1], x[2]))
        
        store = defaultdict(list)
        for x, y, value in mapping:
            store[x].append(value)
        
        return store.values()
    
    def dfs(self, root, mapping, x, y):
        if root is None:
            return
        
        mapping.append((x, y, root.val))
        self.dfs(root.left, mapping, x - 1, y + 1)
        self.dfs(root.right, mapping, x + 1, y + 1)
```
### 方法二
BFS 找 index

Time: O(nlogn)
Space: O(n)

```python
from collections import defaultdict
from collections import deque
class Solution:
    def verticalTraversal(self, root):
        if root is None:
            return []
        
        queue = deque([(root, 0, 0)])
        mapping = []
        while queue:
            node, x, y = queue.popleft()
            
            if node.left:
                queue.append((node.left, x - 1, y + 1))
            if node.right:
                queue.append((node.right, x + 1, y + 1))
                
            mapping.append((x, y, node.val))
        
        mapping = sorted(mapping, key=lambda x: (x[0], x[1], x[2]))
        levels = defaultdict(list)
        for x, y, val in mapping:
            levels[x].append(val)
        return levels.values()
```

## [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)
### 方法一
分治法，找左边的 tail，如果 tail 存在，就连接 root.right

Time: O(n)，遍历 n 个点
Space: O(n)，要走 n 层递归

```python
class Solution:
    def flatten(self, root):
        self.dfs(root)
        return root
    
    def dfs(self, root):
        if root is None:
            return
        
        left_tail = self.dfs(root.left)
        right_tail = self.dfs(root.right)
        
        if left_tail:
            left_tail.right = root.right
            root.right = root.left
            root.left = None
        
        return right_tail or left_tail or root
```

### 方法二
使用 stack 去存放 node.right, node.left。对于每个子树，都 node.left = None，然后 node.right = stack[-1]

Time: O(n)，遍历 n 个节点
Space: O(1)，每次最多只会存 2 个节点

```python
class Solution:
    def flatten(self, root):
        if root is None:
            return None
        
        stack = [root]
        
        while stack:
            node = stack.pop()
            
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
            
            node.left = None
            
            if stack:
                node.right = stack[-1]
            else:
                node.right = None
        
        return root
```

## [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
### 方法一
左右双指针，每次计算 water += max - curt

Time: O(n)
Space: O(1)

```python
class Solution:
    def trap(self, heights):
        if not heights:
            return 0
        
        left, right = 0, len(heights) - 1
        left_max, right_max = heights[left], heights[right]
        water = 0
        
        while left < right:
            if heights[left] < heights[right]:
                left_max = max(left_max, heights[left])
                water += left_max - heights[left]
                left += 1
            else:
                right_max = max(right_max, heights[right])
                water += right_max - heights[right]
                right -= 1
        
        return water
```
### 方法二
使用单调栈来做，每次都 append(right)，water += (water_line - ground) * (right - left - 1)

Time: O(n)
Space: O(n)

```python
class Solution:
    def trapRainWater(self, heights):
        stack = []
        water = 0
        
        for right, height in enumerate(heights):
            while stack and heights[stack[-1]] <= height:
                ground = heights[stack.pop()]
                
                if not stack:
                    continue
                
                left = stack[-1]
                
                water_line = min(heights[left], height)
                
                water += (water_line - ground) * (right - left - 1)
            stack.append(right)
        return water
```

## [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)

### 方法一
递归 Inorder 遍历

Time: O(n)
Space: O(n)

```python
class Solution:
    def inorderTraversal(self, root):
        order = []
        
        self.inorder(root, order)
        
        return order
    
    
    def inorder(self, root, order):
        if root is None:
            return
        
        self.inorder(root.left, order)
        order.append(root.val)
        self.inorder(root.right, order)
```

### 方法二
使用 stack 去取代递归

Time: O(n)
Space: O(n)

```python
class Solution:
    def inorderTraversal(self, root):
        if root is None:
            return []
        
        stack = []
        order = []
        
        while root:
            stack.append(root)
            root = root.left
        
        while stack:
            node = stack.pop()
            
            order.append(node.val)
            
            if node.right:
                node = node.right
                while node:
                    stack.append(node)
                    node = node.left
        
        return order
```

### 方法三
Morris法，每次找 predecessor，将 predecessor.right -> root，如果有，则 unlink

Time: O(n)
Space: O(1)

```python
class Solution:
    def inorderTraversal(self, root):
        if root is None:
            return []
        
        order = []
        
        while root:
            if not root.left:
                order.append(root.val)
                root = root.right
            else:
                predecessor = self.find_predecessor(root)
                
                if predecessor.right:
                    predecessor.right = None
                    
                    order.append(root.val)
                    
                    root = root.right
                else:
                    predecessor.right = root
                    
                    root = root.left
        return order
    
    def find_predecessor(self, root):
        node = root.left
        
        while node.right and node.right != root:
            node = node.right
        return node
```

## [198. House Robber](https://leetcode.com/problems/house-robber/)
### 方法一
dp 解决，dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

Time: O(n)
Space: O(n)

```python
class Solution:
    def rob(self, nums):
        if not nums:
            return 0
        
        if len(nums) <= 2:
            return max(nums)
        
        dp = [0 for _ in range(len(nums))]
        
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        
        return dp[-1]
```

## [House Robber II](https://leetcode.com/problems/house-robber-ii/)
### 方法一
两次 dp，第一次去掉第一个房子，第二次去掉最后一个房子

Time: O(n)
Space: O(n)

```python
class Solution:
    def rob(self, nums):
        if not nums:
            return 0
        
        if len(nums) <= 2:
            return max(nums)
        
        dp = [0 for _ in range(len(nums))]
        
        dp[0], dp[1] = 0, nums[1]
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        
        money = dp[-1]
        
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums) - 1):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
            
        return max(money, dp[len(nums) - 2])
```

## [337. House Robber III](https://leetcode.com/problems/house-robber-iii/)
### 方法一
分治法，分成两种情况，去比较

Time: O(n)
Space: O(n)

```python
class Solution:
    def rob(self, root):
        if root is None:
            return 0
        
        take, not_take = self.dfs(root)
        
        return max(take, not_take)
    
    def dfs(self, root):
        if root is None:
            return 0, 0
        
        left_take, left_not_take = self.dfs(root.left)
        right_take, right_not_take = self.dfs(root.right)
        
        take = root.val + left_not_take + right_not_take
        not_take = max(left_take, left_not_take) + max(right_take, right_not_take)
        
        return take, not_take
```

## House Robber Follow Up
求路径，每次都要去存上一个点的位置。回溯的时候如果 path[i] == i - 1，则 i -= 1，跳到下一个点，否则加入即可.
```python
class Solution:
    def houseRobber(self, A):
        if len(A) == 0:
            return 0
        if len(A) <= 2:
            return max(A)

        n = len(A)
        path = [0 for _ in range(n)]
        dp = [0 for _ in range(n)]
        dp[0], dp[1] = A[0], max(A[0], A[1])
        path[0], path[1] = 0, 0 if A[0] > A[1] else 1

        for i in range(2, n):
            if dp[i - 1] > dp[i - 2] + A[i]:
                dp[i] = dp[i - 1]
                path[i] = i - 1
            else:
                dp[i] = dp[i - 2] + A[i]
                path[i] = i - 2
        
        print(dp)
        print(self.get_path(path))

        return dp[-1]

    def get_path(self, path):
        i = len(path) - 1
        result = set()
        while 0 <= i and i not in result:
            if path[i] == i - 1:
                i -= 1
            else:
                result.add(i)
                i = path[i]
        return sorted(list(result))
```
对于 House Robber II 来说，需要注意的就是初始化问题，get_path 函数还是可以不用变的。