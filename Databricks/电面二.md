# 电面二总结

[题库](https://leetcode.com/company/databricks/)

## [742. Closest Leaf in a Binary Tree](https://leetcode.com/problems/closest-leaf-in-a-binary-tree/)
看成一个图，从 target node 去找叶子节点

DFS 构图，找到 start node， O(n)
BFS 找叶子节点，O(n)

Time: O(n)
Space: O(n) 存放边和节点

```python
from collections import deque

class Solution:
    def findClosestLeaf(self, root, k):
        if root is None:
            return -1
        
        parents = {}
        target = self.find_target(root, k, parents)
        
        queue = deque([target])
        visited = {target}
        while queue:
            node = queue.popleft()
            
            if not node.left and not node.right:
                return node.val
            if node.left and node.left not in visited:
                queue.append(node.left)
                visited.add(node.left)
            if node.right and node.right not in visited:
                queue.append(node.right)
                visited.add(node.right)
            if node in parents and parents[node] not in visited:
                queue.append(parents[node])
                visited.add(parents[node])
        
        return -1

    def find_target(self, root, k, parents):
        if root is None:
            return None
        
        result = root
        node = None
        
        if root.left:
            parents[root.left] = root
            node = self.find_target(root.left, k, parents)
            if node.val == k:
                result = node
        if root.right:
            parents[root.right] = root
            node = self.find_target(root.right, k, parents)
            if node.val == k:
                result = node
        return result
```

## [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)
### 方法一
不断交换 nums[i] 和 nums[nums[i] - 1]，注意 nums[i] != nums[nums[i] - 1] 和 0 <= nums[i] < n
Time: O(n)
Space: O(1)

```python
class Solution:
    def firstMissingPositive(self, nums):
        n = len(nums)
        
        for i in range(n):
            while 0 <= nums[i] < n and nums[i] != i + 1 and nums[i] != nums[nums[i] - 1]:
                temp = nums[nums[i] - 1]
                nums[nums[i] - 1] = nums[i]
                nums[i] = temp
                
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        return n + 1
```

### 方法二
使用 HashMap { n: n } 如果 num in hash_map，就删除 hash_map[num]，返回 min(hash_map)，就是第一个 Missing 正整数
注意这里是 1 -> n + 1

Time: O(n)
Space: O(n)

```python
class Solution:
    def firstMissingPositive(self, nums):
        store = { n : n for n in range(1, len(nums) + 2) }
        
        for num in nums:
            if num in store:
                del store[num]
    
        return min(store)
```

## [218. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)
### 方法一
分成左右两边 get skyline，再合并。每次如果 y 值变化了，就要更新一下 skyline

Time: O(nlogn) -> T(n) = 2 * T(n/2) + 2N -> O(nlogn)
Space: O(n) -> 保存结果

```python
class Solution:
    """
    @param buildings: A list of lists of integers
    @return: Find the outline of those buildings
    """
    def getSkyline(self, buildings):
        n = len(buildings)

        # Base case
        if n == 0:
            return []
        if n == 1:
            x_start, x_end, y = buildings[0]
            # 左上和右下
            return [[x_start, y], [x_end, 0]]

        left_skyline = self.getSkyline(buildings[:n // 2])
        right_skyline = self.getSkyline(buildings[n // 2:])

        return self.merge_skylines(left_skyline, right_skyline)

    def merge_skylines(self, left_skyline, right_skyline):
        left_len, right_len = len(left_skyline), len(right_skyline)
        left = right = 0
        current_y = left_y = right_y = 0
        skyline = []

        # 合并共有的部分
        while left < left_len and right < right_len:
            left_point, right_point = left_skyline[left], right_skyline[right]
            # 选择第一个点
            if left_point[0] < right_point[0]:
                x, left_y = left_point
                left += 1
            else:
                x, right_y = right_point
                right += 1

            # 合并楼层的高
            max_y = max(left_y, right_y)
            # 如果 y 值要变，要更新 skyline 了
            if max_y != current_y:
                self.update_skyline(x, max_y, skyline)
                current_y = max_y

        # 将剩下的部分加入到 skyline
        self.append_skyline(left_skyline, left, left_len, current_y, skyline)
        self.append_skyline(right_skyline, right, right_len, current_y, skyline)

        return skyline

    def update_skyline(self, x, y, skyline):
        # 没有这个点的时候就加入
        if not skyline or skyline[-1][0] != x:
            skyline.append([x, y])
        # 否则更新最后一个点的 y 值
        else:
            skyline[-1][1] = y

    def append_skyline(self, rest_skyline, start, length, current_y, skyline):
        for i in range(start, length):
            x, y = rest_skyline[i]
            # 如果 y 值要变，要更新 skyline 了
            if current_y != y:
                self.update_skyline(x, y, skyline)
                current_y = y
```

## [239. Sliding Window Maximum]()

### 方法一
Brute Force
Time: O((n - k + 1) * k) -> O(n^2)
Space: O(1)

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        window = deque([])
        
        n = len(nums)
        k = min(n, k)
        
        for i in range(k - 1):
            window.append(nums[i])
        
        results = []
        for i in range(k - 1, n):
            window.append(nums[i])
            
            results.append(max(window))
            
            window.popleft()
        
        return results
```

### 方法二
BST
Time: O((n - k + 1) * logk)
Space: O(k)

```python
import heapq

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        n = len(nums)
        k = min(k, n)
        
        window = []
        
        for i in range(k - 1):
            heapq.heappush(window, -nums[i])
        
        results = []
        for i in range(k - 1, n):
            # 加入右边一个元素
            heapq.heappush(window, -nums[i])
            # 获取当前最大值 
            results.append(-window[0])
            # 从 heap 中移除左边的元素
            window.remove(-nums[i - k + 1])
            heapq.heapify(window)
        
        return results
```
### 方法三
单调双端队列

Time: O(n)
Space: O(k)

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums, k):
        if not nums:
            return []
        
        n = len(nums)
        k = min(k, n)
        
        
        queue = deque([])
        for i in range(k - 1):
            self.push(nums, queue, i)
            
        results = []
        for i in range(k - 1, n):
            self.push(nums, queue, i)
            results.append(nums[queue[0]])
            
            if i - k + 1 == queue[0]:
                queue.popleft()
        
        return results
    
    def push(self, nums, queue, i):
        while queue and nums[queue[-1]] < nums[i]:
            queue.pop()
        queue.append(i)
```

## [91. Decode Ways](https://leetcode.com/problems/decode-ways/)

### 方法一
dp 解法，dp[i] = dp[i - 1] + dp[i - 2] | dp[i - 1] } dp[i - 2]
如果遇到 0，就返回 0，因为此处不能解码

Time: O(n)
Space: O(n)

```python
class Solution:
    def numDecodings(self, s):
        if not s or s[0] == '0':
            return 0
        
        n = len(s)
        dp = [0 for _ in range(n + 1)]
        dp[0], dp[1] = 1, 1
        
        for i in range(2, n + 1):
            if 10 <= int(s[i - 2:i]) <= 26 and s[i - 1] != '0':
                dp[i] = dp[i - 2] + dp[i - 1]
            elif int(s[i - 2:i]) == 10 or int(s[i - 2:i]) == 20:
                dp[i] = dp[i - 2]
            elif s[i - 1] != '0':
                dp[i] = dp[i - 1]
            else:
                return 0
        
        return dp[n]
```

### 方法二
dfs + memo

Time: O(n) ，如果不用 memo 就是 O(2^n)，因为用了 memo ，所以每次只需要访问所以 index，就是 O(n)
Space: O(n)

```python
class Solution:
    def numDecodings(self, s):
        if not s or s[0] == '0':
            return 0
            
        return self.dfs(s, 0, {})
    
    def dfs(self, s, start, memo):
        if start in memo:
            return memo[start]
            
        if start == len(s):
            return 1
            
        if s[start] == '0':
            return 0
        
        result = self.dfs(s, start + 1, memo)
        
        if start + 2 <= len(s) and int(s[start: start + 2]) <= 26:
            result += self.dfs(s, start + 2, memo)
        
        memo[start] = result
        return result
```

## [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)
### 方法一
Array + Hash Table
删除的时候将最后一个放到 index，再 pop() 即可

Time: O(1)
Space: O(n)

```python
import random

class RandomizedSet:

    def __init__(self):
        self.nums = []
        self.positions = {}
        self.length = 0
        
    def insert(self, val: int) -> bool:
        if val in self.positions:
            return False
        
        self.nums.append(val)
        self.positions[val] = self.length
        self.length += 1
        
        return True
        
    def remove(self, val: int) -> bool:
        if val not in self.positions:
            return False
        
        last, index = self.nums[-1], self.positions[val]
        
        self.nums[index] = last
        self.positions[last] = index
        
        self.nums.pop()
        
        del self.positions[val]
        self.length -= 1
        
        return True

    def getRandom(self) -> int:
        return self.nums[random.randint(0, self.length - 1)]
```

## [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)
### 方法一
将删除的变成 None

Time: O(1)
Space: O(n)

```python
from collections import defaultdict
import random

class RandomizedCollection:

    def __init__(self):
        self.nums = []
        self.positions = defaultdict(set)
        self.length = 0
        

    def insert(self, val: int) -> bool:
        self.nums.append(val)
        self.positions[val].add(self.length)
        self.length += 1
        
        return len(self.positions[val]) == 1
        

    def remove(self, val: int) -> bool:
        if not self.positions[val]:
            return False
        
        index = self.positions[val].pop()
        
        self.nums[index] = None
        self.length -= 1
        return True
        

    def getRandom(self) -> int:
        x = None
        while x is None:
            x = random.choice(self.nums)
            
        return x
```
